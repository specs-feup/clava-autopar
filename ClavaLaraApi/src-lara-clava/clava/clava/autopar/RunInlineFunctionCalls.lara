/**************************************************************
* 
*                       RunInlineFunctionCalls
* 
**************************************************************/
import clava.ClavaType;

var countCallInlinedFunction;
aspectdef RunInlineFunctionCalls

	var func_name = {};
	countCallInlinedFunction = 0;
	select file.function end
	apply
		if (func_name[$function.name] === undefined)
		{
			func_name[$function.name] = {};
			func_name[$function.name].innerCallNumber = 0;
			func_name[$function.name].CallingFunc = [];
		}
	end

	select file.function end
	apply
		var innerCalls = $function.descendants('call');

		func_name[$function.name].innerCallNumber = innerCalls.length;
		for(var obj of innerCalls)
			if (safefunctionCallslist.indexOf(obj.name) === -1)
				func_name[$function.name].CallingFunc.push(obj.name);
	end




	var flag = false;
	while(1)
	{
		flag = false;
		for (var caller_func in func_name)
			for(var calling of func_name[caller_func].CallingFunc)
				if (calling !== caller_func && func_name[calling] !== undefined )
				{
					for(var func of func_name[calling].CallingFunc)
						if (func_name[caller_func].CallingFunc.indexOf(func) ===-1 )
						{
							func_name[caller_func].CallingFunc.push(func);
							flag = true;
						}
				}

		if (flag === false)
			break;
	}


	
	var excluded_function_list = [];
	// check for recursive function calls
	for (var caller_func in func_name)
	{
		if (
			func_name[caller_func].CallingFunc.indexOf(caller_func) !== -1 &&
			excluded_function_list.indexOf(caller_func) === -1 // not exist
			)
			{
				excluded_function_list.push(caller_func);
			}	
	}


	select file.function end
	apply
		var innerCalls = $function.descendants('call');

		for(var obj of innerCalls)
			if (safefunctionCallslist.indexOf(obj.name) === -1 && func_name[obj.name] === undefined  )
				if (excluded_function_list.indexOf($function.name) === -1) // not exist
					excluded_function_list.push($function.name);
	end

	
	select file.function.body.vardecl end
	apply
		if (excluded_function_list.indexOf($function.name) === -1)
			excluded_function_list.push($function.name);
	end
	condition $vardecl.storageClass === 'static' end


	for (var caller_func in func_name)
		for(var calling of func_name[caller_func].CallingFunc)
			if (
				excluded_function_list.indexOf(calling) !== -1 &&
				excluded_function_list.indexOf(caller_func) === -1
				)
				{
					excluded_function_list.push(caller_func);
				}



	var sorted = [];
	for (var key in func_name)
	{
  		sorted.push([ key, func_name[key].innerCallNumber ]);
	}
	sorted.sort(function compare(obj1, obj2) {return obj1[1] - obj2[1];});


	for(i in sorted)
		if (excluded_function_list.indexOf(sorted[i][0]) === -1)
		{
			call callInline(sorted[i][0]);
		}
end



/**************************************************************
* 
*                       callInline
* 
**************************************************************/
aspectdef callInline
	input func_name end

	select file.function.call end
	apply
		var exprStmt = $call.astAncestor('ExprStmt');

		if (exprStmt === undefined)
		{
			continue;
		}

		if (
					(// funcCall(...)
					exprStmt.astChildren[0].joinpointType === 'call' && 
					exprStmt.descendantsAndSelf('call').length ===1 && 
					exprStmt.astChildren[0].name === func_name
					) 
			||
					(// var op funcCall(...)
					exprStmt.astChildren[0].joinpointType === 'binaryOp' && 
					exprStmt.astChildren[0].right.joinpointType === 'call' && 
					exprStmt.astChildren[0].right.descendantsAndSelf('call').length === 1
					)
			)
			{

				var o = null;
				call o : inlinePreparation(func_name, $call, exprStmt);
				

				if(o.$newStmts.length > 0) 
				{					
					var replacedCallStr = '// ClavaInlineFunction : ' + exprStmt.code + '  countCallInlinedFunction : ' + countCallInlinedFunction;
					exprStmt.insert before replacedCallStr;

					for(var $newStmt of o.$newStmts)
					{
						exprStmt.insertBefore($newStmt);	
					}

					exprStmt.detach();
				}
			}

	end
	condition $call.name === func_name && $call.astAncestor('ForStmt') !== undefined end

end	


aspectdef aspec_rebuild
	select program end
	apply
		$program.rebuild();
	end 
end

/**************************************************************
* 
*                       inlinePreparation
* 
**************************************************************/
aspectdef inlinePreparation
	input func_name, callStmt, exprStmt end
	output replacedCallStr, $newStmts end

	replacedCallStr = '';

	$newStmts = [];	

	if (func_name !== 'exact_solution')
		return;

	var funcJP = null;
	var funcJP_backup = null;
	select function end
	apply
		funcJPOrginal = $function;

		funcJP = $function.clone(func_name + '_clone');
		
		funcJP_backup = $function.copy();
		funcJP_backupCode = $function.code;
		funcAst_backup = $function.ast;

		break;
	end
	condition $function.name === func_name && $function.hasDefinition === true end

	if (funcJP === null)
	{
		funcJP.detach();
		return;
	}


	returnStmtJPs = [];
	select funcJP.body.stmt end
	apply
		returnStmtJPs.push($stmt);
	end
	condition $stmt.astName === 'ReturnStmt' end

	if (
		funcJP.functionType.returnType.code === 'void'
		&&
			(
				returnStmtJPs.length > 1 || 
				(returnStmtJPs.length === 1 && returnStmtJPs[0].isLast === false )
			)
		)
	{
		funcJP.detach();
		return;
	}
	else // function return !== void
	{
		if  (
				returnStmtJPs.length > 1 || 
				(returnStmtJPs.length === 1 && returnStmtJPs[0].isLast === false )
			)
		{
			funcJP.detach();
			return;
		}

	}

	
	if (funcJP.functionType.returnType.code === 'void' && returnStmtJPs.length === 1)
	{
		returnStmtJPs[0].detach();
	}

	countCallInlinedFunction = countCallInlinedFunction + 1;

	var param_table = {};

	select funcJP.body.vardecl end
	apply
		if ($vardecl.qualifiedName !== $vardecl.name)
			continue;
		
		var newDeclName = $vardecl.qualifiedName + "_" + countCallInlinedFunction;
		param_table[$vardecl.name] = newDeclName;
		$vardecl.name =  newDeclName;

	end

	select funcJP.body.varref end
	apply
		if (param_table[$varref.name] !== undefined)
		{			
			$varref.setName(param_table[$varref.name]);
		}

	end

	select funcJP.body.varref end
	apply
		$varref.useExpr.replaceWith($varref);
	end
	condition $varref.vardecl !== undefined && $varref.vardecl.isParam && $varref.kind === 'pointer_access' end
	
	var param_index = 0;
	param_table = {};
	select funcJP.param end
	apply
		if ($param.type.code.indexOf('void ') !== -1)
		{
			funcJP.detach();
			return;			
		}

		if ($param.type.isBuiltin === true)
		{
			
			var orgparamName = $param.qualifiedName;
			param_table[$param.name] = $param.qualifiedName + "_" + countCallInlinedFunction;			
			$param.name = param_table[$param.name];

			$newVardecl = ClavaJoinPoints.varDecl($param.name, callStmt.argList[param_index].copy());

			funcJP.body.insertBegin($newVardecl);
		}
		
		else if ($param.type.isArray === true)
		{
			if (callStmt.argList[param_index].joinpointType === 'unaryOp')
			{
				funcJP.detach();
				return;

				var arrayVarObj = callStmt.argList[param_index].descendantsAndSelf('arrayAccess')[0];

				param_table[$param.name] = arrayVarObj.arrayVar.code;
				for(var index = 0 ; index < arrayVarObj.subscript.length - ($param.code.split('[').length-1) ; index++)
				{
					param_table[$param.name] += '[' + arrayVarObj.subscript[index].code +']';
				}				
			}
			else if (callStmt.argList[param_index].joinpointType === 'cast')
			{

				if (callStmt.argList[param_index].vardecl.type.unwrap.code !== callStmt.argList[param_index].type.unwrap.code)
				{
					funcJP.detach();
					return;
				}

				param_table[$param.name] = callStmt.argList[param_index].subExpr.code;				
			}
			else
			{
				param_table[$param.name] = callStmt.argList[param_index].code;
			}
			$param.name = param_table[$param.name];
		}
		else if ($param.type.isPointer === true)
		{
			param_table[$param.name] = callStmt.argList[param_index].code.allReplace({'&':''});
			$param.name =  param_table[$param.name];

		}

		param_index = param_index + 1;
	end

	select funcJP.body.varref end
	apply
		if (param_table[$varref.name] !== undefined)
			$varref.setName(param_table[$varref.name]);
	end
	condition $varref.vardecl.isParam === true  end	
	
	
    select funcJP.body.vardecl end
    apply        
        var varrefs = [];
        var $typeCopy = ClavaType.getVarrefsInTypeCopy($vardecl.type, varrefs);

        for(var $varref of varrefs)
        {
        	$varref.name = param_table[$varref.name];
        }
                
        $vardecl.type = $typeCopy;
    end
    

	if (exprStmt.astChildren[0].joinpointType === 'binaryOp')
	{
		var ret_str_replacement = exprStmt.astChildren[0].astChildren[0].code;

		if (exprStmt.astChildren[0].kind === 'assign')
			ret_str_replacement += ' = ';
		else if (exprStmt.astChildren[0].kind === 'add_assign')
			ret_str_replacement += ' += ';
		else if (exprStmt.astChildren[0].kind === 'sub_assign')
			ret_str_replacement += ' -= ';
		else if (exprStmt.astChildren[0].kind === 'mul_assign')
			ret_str_replacement += ' *= ';

		retJPs = funcJP.body.stmts.filter(function(obj){if (obj.astName === 'ReturnStmt') {return obj;}});
		
		for(retJP of retJPs)
		{
			retJP.insert replace ret_str_replacement + retJP.astChildren[0].code + ';';
		}

	}

    select funcJP.body.comment end
    apply
        $comment.detach();
    end

	
	select funcJP.body.childStmt end
	apply
		$newStmts.push($childStmt.copy());
		replacedCallStr += $childStmt.code + '\n';
	end
	
	replacedCallStr = replacedCallStr.allReplace({' const ':' '});

	funcJP.detach();
end	
